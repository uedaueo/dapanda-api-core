/*
 * This code is generated by blanco Framework.
 */
package dapanda.api.core.blanco.db.common.util;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import dapanda.api.core.blanco.db.common.exception.DeadlockException;
import dapanda.api.core.blanco.db.common.exception.IntegrityConstraintException;
import dapanda.api.core.blanco.db.common.exception.TimeoutException;

/**
 * A utility class commonly used by blancoDb.
 * This class is used in the source code generated by blancoDb. <br>
 * This class is used from the source code generated by blancoDb. It is not recommended to call it directly.
 * @since 2006.03.02
 * @author blanco Framework
 */
public class BlancoDbUtil {
    static final private Map<String, String> mapComparison = new HashMap<String, String>() {
        {
            put("EQ", "=");
            put("NE", "<>");
            put("GT", ">");
            put("LT", "<");
            put("GE", ">=");
            put("LE", "<=");
            put("LIKE", "LIKE");
            put("NOT LIKE", "NOT LIKE");
        }
    };

    static final public Long QUERY_TIMEOUT_DEFAULT = 60000L;

    /**
     * Converts SQL exceptions to blanco Framework exception objects.<br>
     * Converts SQL exceptions that should be converted to blanco Framework exception objects.<br>
     * If there is no destination to be converted, the original object is returned as is.
     *
     * @param ex Exception object returned from JDBC.
     * @return The converted SQL exception object; SQLException or its inherited classes IntegrityConstraintException, DeadlockException, and TimeoutException will be returned.
     */
    public static SQLException convertToBlancoException(final SQLException ex) {
        if (ex.getSQLState() != null) {
            if (ex.getSQLState().startsWith("23")) {
                final IntegrityConstraintException exBlanco = new IntegrityConstraintException("Changes failed due to database constraint violation." + ex.toString(), ex.getSQLState(), ex.getErrorCode());
                exBlanco.initCause(ex);
                return exBlanco;
            } else if (ex.getSQLState().equals("40001")) {
                final DeadlockException exBlanco = new DeadlockException("Changes failed due to database deadlock." + ex.toString(), ex.getSQLState(), ex.getErrorCode());
                exBlanco.initCause(ex);
                return exBlanco;
            } else if (ex.getSQLState().equals("HYT00")) {
                final TimeoutException exBlanco = new TimeoutException("Changes failed due to database timeout." + ex.toString(), ex.getSQLState(), ex.getErrorCode());
                exBlanco.initCause(ex);
                return exBlanco;
            }
        }
        return ex;
    }

    /**
     * Converts JDBC Timestamp to Date type.
     *
     * Converts java.sql.Timestamp type to java.util.Date type.<br>
     * This method is used from the source code generated by blancoDb. It is not recommended to call it directly.
     *
     * @param argTimestamp Gives the Timestamp type of JDBC.
     * @return Returns the converted java.util.Date.
     */
    public static final Date convertTimestampToDate(final Timestamp argTimestamp) {
        if (argTimestamp == null) {
            return null;
        }
        return new Date(argTimestamp.getTime());
    }

    /**
     * Auto-generates dynamic conditional clauses from input parameters.
     *
     * Generates dynamic SQL from the map generated based on the Excel definition and the parameters given at runtime.<br>
     * This method is used from the source code generated by blancoDb. It is not recommended to call it directly.
     *
     * @param argMapClause Specifies the map of dynamic condition definitions.
     * @param argParameter Specifies the parameters for selecting dynamic condition.
     * @param argQuery Specifies the parameters for selecting dynamic condition.
     * @param argExpectedTag Specifies the tag to be removed if null is passed as a parameter.
     * @param <T>  Virtual parameter for BlancoDbDynamicParameter.
     * @return Returns the query after Tag replacement.
     * @throws SQLException It may throw an SQL exception.
     */
    public static final <T> String createDynamicClause(final Map<String, BlancoDbDynamicClause> argMapClause, final BlancoDbDynamicParameter<T> argParameter, final String argQuery, final String argExpectedTag) throws SQLException {
        String query = argQuery;
        if (argParameter != null) {
            String key = argParameter.getKey();

            List<T> values = argParameter.getValues();
            if (key != null) {
                BlancoDbDynamicClause dynamicClause = argMapClause.get(key);
                if (dynamicClause != null) {
                    /* Since the dynamic conditional clauses map is auto-generated, it is assumed that there are no invalid values. */
                    StringBuffer sb = new StringBuffer();
                    String tag = dynamicClause.getTag();
                    String condition = dynamicClause.getCondition();

                    if ("LITERAL".equals(condition)) {
                        if (values != null && values.size() == 1) {
                            BlancoDbDynamicLiteral literal = (BlancoDbDynamicLiteral) values.get(0);
                            if (literal != null && !literal.getInvalid() && dynamicClause.getItems() != null) {
                                sb.append(" ");
                                int count = 0;
                                for (String item : dynamicClause.getItems()) {
                                    if (count > 0) {
                                        sb.append(",");
                                    }
                                    sb.append(item);
                                    count++;
                                }
                                sb.append(" ");
                            }
                        }
                    } else if ("FUNCTION".equals(condition)) {
                        if (values != null && values.size() == 1) {
                            sb.append(" ");
                            sb.append(dynamicClause.getItems().get(0));
                            sb.append(" ");
                        }
                    } else if ("ORDERBY".equals(condition)) {
                        if (values != null && values.size() > 0) {
                            sb.append("ORDER BY ");
                            int count = 0;
                            for (T value : values) {
                                BlancoDbDynamicOrderBy orderBy = (BlancoDbDynamicOrderBy) value;
                                if (count > 0) {
                                    sb.append(", ");
                                }
                                String column = dynamicClause.getItem(orderBy.getColumn());
                                if (column == null) {
                                    throw new SQLException("The [ " + orderBy.getColumn() + " ] specified as input is undefined in the definition document.", "42S22", 9999);
                                }
                                sb.append(column);
                                if (!"ASC".equals(orderBy.getOrder())) {
                                    sb.append(" DESC");
                                } else {
                                    sb.append(" ASC");
                                }
                                count++;
                            }
                        }
                    } else if ("BETWEEN".equals(condition)) {
                        if (values != null && values.size() == 2) {
                            sb.append(" " + dynamicClause.getLogical() + " ( " + dynamicClause.getItems().get(0) + " BETWEEN ? AND ? )");
                        }
                    } else if ("NOT BETWEEN".equals(condition)) {
                        if (values != null && values.size() == 2) {
                            sb.append(" " + dynamicClause.getLogical() + " ( " + dynamicClause.getItems().get(0) + " NOT BETWEEN ? AND ? )");
                        }
                    } else if ("IN".equals(condition)) {
                        if (values != null && values.size() > 0) {
                            sb.append(" " + dynamicClause.getLogical() + " ( " + dynamicClause.getItems().get(0) + " IN ( ");
                            int count = 0;
                            for (T value : values) {
                                if (count > 0) {
                                    sb.append(", ");
                                }
                                sb.append("?");
                                count++;
                            }
                            sb.append(" )");
                            sb.append(" )");
                        }
                    } else if ("NOT IN".equals(condition)) {
                        if (values != null && values.size() > 0) {
                            sb.append(" " + dynamicClause.getLogical() + " ( " + dynamicClause.getItems().get(0) + " NOT IN ( ");
                            int count = 0;
                            for (T value : values) {
                                if (count > 0) {
                                    sb.append(", ");
                                }
                                sb.append("?");
                                count++;
                            }
                            sb.append(" )");
                            sb.append(" )");
                        }
                    } else if ("COMPARE".equals(condition)) {
                        if (values != null && values.size() > 0) {
                            String logicalOperator = "OR";
                            if (argParameter.getLogicalOperator() != null && argParameter.getLogicalOperator().equalsIgnoreCase("AND")) {
                                logicalOperator = "AND";
                            }
                            sb.append(" " + dynamicClause.getLogical() + " ( ");
                            for (int count = 0; count < values.size(); count++) {
                                if (count > 0) {
                                    sb.append(" " + logicalOperator + " ");
                                }
                                sb.append(dynamicClause.getItems().get(0) + " " + mapComparison.get(dynamicClause.getComparison()) + " ?");
                            }
                            sb.append(" )");
                        }
                    }
                    query = argQuery.replace("${" + tag + "}", sb.toString());
                }
            }
        } else {
            query = argQuery.replace("${" + argExpectedTag + "}", "");
        }
        return query;
    }

    /**
     * Add MAX_EXECUTION_TIME optimizer hint to iterator query.
     *
     * @param argTimeout Timeout value in milli-seconds.
     * @param argQuery Query String to be parsed.
     * @return Returns the query appended timeout hint.
     */
    public static final String createTimeoutHintMySQL(final Long argTimeout, final String argQuery) {
        String query = argQuery;
        if (query != null && query.length() > 0 && argTimeout != null && argTimeout > 0L) {
            String strSelect = "\\bselect\\b";
            String strHint = "SELECT /*+ MAX_EXECUTION_TIME(" + argTimeout + ") */";

            query = Pattern.compile(strSelect, Pattern.CASE_INSENSITIVE).matcher(query).replaceFirst(strHint);
        }
        return query;
    }

    /**
     * Input parameter function for dynamic SQL.
     *
     * Applies parameters given at runtime to dynamically generated conditional clauses.<br>
     * This method is used from the source code generated by blancoDb. It is not recommended to call it directly.
     *
     * @param argStatement This is a dynamically defined preparedStatement.
     * @param values This is a dynamically defined preparedStatement.
     * @param startIndex The starting index of the parameter.
     * @param <T>  Virtual parameter for BlancoDbDynamicParameter.
     * @return Return the query after Tag replacement.
     * @throws SQLException SQLException may be thrown.
     */
    public static final <T> int setInputParameter(final PreparedStatement argStatement, final List<T> values, final Integer startIndex) throws SQLException {
        int index = startIndex;
        for (T value : values) {
            /*
             * It seems to take care of the NULL case, but it may cause an error depending on the Database engine.
             * e.g. NG for SQLServer, OK for MySQL connector.
             */
            argStatement.setObject(index, value);
            index++;
        }
        return index;
    }
}
